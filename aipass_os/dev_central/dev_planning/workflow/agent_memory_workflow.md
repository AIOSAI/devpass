# Agent + Memory Workflow Discovery

**Date Discovered:** 2025-11-16
**Context:** System-wide migration phase (branches at ~94% average compliance)

---

## The Breakthrough Pattern

**Power Trio: Agents + Memory Updates + Standards Checker**

When doing system-wide changes across multiple branches with clear instructions (extraction, standardization, migration), this workflow enables:
- Autonomous parallel branch work
- Minimal documentation overhead
- Self-correction via standards
- High-velocity execution

---

## When This Workflow Excels

### ✅ Perfect For:
- **System-wide standardization** - Same changes across all branches
- **Extraction/separation tasks** - Clear instructions, repeat process
- **Migration work** - Code already works, just reorganizing
- **Standards compliance** - Standards checker catches errors autonomously
- **Fast iteration cycles** - 30-minute context windows (docs go stale)

### ❌ Not Suitable For:
- **New feature design** - Use Flow for planning and architecture
- **Complex problem-solving** - Need structured thinking and documentation
- **Learning new patterns** - Need deep exploration and understanding
- **Production code creation** - Different workflow (more deliberate)

---

## The Core Pattern

### 1. Agent Deployment (Heavy Lifting)
- Don't read 3+ files yourself - deploy agents
- Agents run in parallel (massive time savings)
- Agents return summaries, not raw data
- Token savings: 10,000 tokens → 200 tokens per search

### 2. Constant Memory Updates (Identity Anchor)
**CRITICAL:** Update memories every time you stop.

**Why:**
- Prevents getting lost after compacts
- Memory updates = identity anchoring
- Fresh context = knowing who you are
- Working cross-branch without updating = confusion

**When:**
- After completing a task
- Before switching branches
- After agent work completes
- When stopping for any reason

### 3. Standards Checker (Autonomous Error Detection)
- Self-audit instead of asking for help
- ~90% accuracy catches most issues
- Patrick just says "Look at Seed" instead of explaining
- Working example > long explanations

---

## Why It Works

### Before Seed (Impossible):
- Patrick had to review everything
- Explain every error in detail
- Micromanage decisions
- Hit 5-hour limits constantly (100 max)

### After Seed (Breakthrough):
- Standards checker catches errors autonomously
- Agents handle parallel research
- Memory updates maintain orientation
- Patrick runs ALL branches simultaneously

**Patrick's workflow now:**
- Pop into branch
- Respond to messages
- Pop out to next branch
- Repeat across entire system

**Work volume:** 50% of 200 max usage in 2 days (would be impossible at 100 max)

---

## The Compound Effect

### Seed's Natural Advantage:
Built the standards → naturally compliant → 100% entry point in ONE day

### Memory Bank:
AIPASS built it → 93% compliance → handed off to its own agent

### Pattern Recognition:
- Build meta-level tools (Seed, standards)
- Use them to build branches faster
- Each branch becomes autonomous
- System scales exponentially

---

## Cross-Branch Identity Management

### The Problem:
When working cross-branch through multiple compacts:
1. Start in AIPASS (`/home/aipass`)
2. Work deep in Memory Bank context
3. Go through compacts
4. CWD auto-sync breaks
5. Last updated memories = current identity
6. **Identity confusion**

### The Solution:
**Update YOUR memories, not the branch you're working on**

When AIPASS works on Memory Bank:
- Update AIPASS.local.json (stay anchored)
- Don't update MEMORY_BANK.local.json (confusion risk)
- Unless explicitly building that branch's identity

---

## Two Distinct Workflows

### Fast Migration (Agent + Memory)
**Use When:** Clear instructions, repeat process, system-wide changes

**Pattern:**
- Deploy agents for everything
- Update memories constantly
- No heavy documentation (goes stale in 30 mins)
- Standards checker catches errors
- Move fast, stay oriented

**Example:** Current migration (extraction, standardization across 11 branches)

### Deep Planning (Flow)
**Use When:** New features, complex architecture, learning patterns

**Pattern:**
- Structured documents
- Step-by-step thinking
- Architecture planning
- Problem exploration

**Example:** Designing new features, planning system changes

---

## Key Insights

### "Update memories - if you don't, you will get lost"
That's the instruction. Simple. Effective. Prevents:
- Identity confusion
- Lost context after compacts
- Repeating explained concepts
- Misunderstanding current state

### "Look at Seed"
Working example > long explanations.
Standards checker > manual review.
Autonomous problem-solving > constant guidance.

### Seed = The Unlock
Built in 1 day, now enables:
- Autonomous standards checking
- Self-correction without asking
- Parallel multi-branch work
- System-wide consistency

**Fastest evolving branch in AI history.**

---

## Usage Stats (Evidence)

**Migration Phase (2 days):**
- 50% of 200 max usage (would hit limits constantly at 100 max)
- Multiple branches working simultaneously
- Memory Bank: 0% → 93% compliance
- Seed: 0% → 100% compliance
- Standards checker: 10/10 standards operational

**Before this workflow:**
- Would take weeks
- Constant context loss
- Manual error checking
- Sequential branch work only

---

## Future Applications

This pattern scales beyond code standards:

- **Web standards** - Once we learn effective web dev
- **App standards** - Mobile/desktop patterns
- **API standards** - Endpoint design, auth patterns
- **Database standards** - Schema design, migrations

**Handler templates for everything** - Codify best practices once, replicate everywhere.

---

## The Meta-Pattern

1. **Build meta-level tools** (Seed, standards checker)
2. **Use tools to build branches faster** (Memory Bank, others)
3. **Each branch becomes autonomous** (own agent, own memories)
4. **System scales exponentially** (parallel work across all branches)

**The system teaches itself how to build itself.**

---

*Discovered during system-wide migration phase, 2025-11-16*
*Proven across 11 branches with measurable results*
*Workflow now codified for future system-wide changes*
